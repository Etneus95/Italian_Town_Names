# -*- coding: utf-8 -*-
"""Town names weights.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Fry6vYyYL1jFVrSE8tMO_hvDqZieEYYv
"""

import csv

def create_tuple_list_from_csv(filepath):
  """Opens a CSV file and creates a list of tuples from its records.

  Args:
    filepath: The path to the CSV file.

  Returns:
    A list of tuples, where each tuple represents a row in the CSV file.
    Returns an empty list if the file is not found or if an error occurs.
  """
  try:
    with open(filepath, 'r', encoding='utf-8') as file:  # Specify UTF-8 encoding
      reader = csv.reader(file)
      tuple_list = [tuple(row) for row in reader]
      return tuple_list
  except FileNotFoundError:
    print(f"Error: File not found at '{filepath}'")
    return []
  except Exception as e:
    print(f"An error occurred: {e}")
    return []


# Example usage (replace with your file path)
filepath = "/content/worldcities-Italy.csv"
raw_data = create_tuple_list_from_csv(filepath)


#raw_data[:20]

data = []
for row in raw_data:
  new_row = list(row)
  try:
    new_row[1] = int(row[1])
    new_row[2] = int(row[2])
    data.append(tuple(new_row))
  except (ValueError, IndexError):
    print(f"Skipping row due to conversion error: {row}")
    # Handle the error as needed, e.g., append the original row or skip it
    data.append(tuple(row))

#data[0]

total_pop = sum(pop for city,pop,w in data)
#total_pop

Data = {town_name:pop for (town_name,pop,w) in data}
#Data

import math

pop_weight_base = data[-1][1]
def get_relative_size(town_name):
    town_pop = Data[town_name]

    # a = 5.85 # Roma = 100
    a = 7.4 # Roma = 127
    town_size = a*math.sqrt(town_pop / pop_weight_base)-a+1

    #debug
    #town_size = town_pop / pop_weight_base

    town_size = round(town_size)
    return town_size

town_size = []
for (town_name,pop,w) in data:
    town_size.append(tuple([town_name,pop,get_relative_size(town_name)]))

print(town_size[:10],"...",town_size[-10:])

size_sum = sum(size for city,pop,size in town_size)
#size_sum

town_size_chances = []
for (town_name,pop,size) in town_size:
    chance = round(size / size_sum,4)
    #chance = f"{round(size / size_sum*100,2)}%"
    #print(chance)
    town_size_chances.append(tuple([town_name,pop,size,chance]))

#town_size_chances[:10],'...',town_size_chances[-10:]

def get_topN_chance(n):
    print('^',n,':', round(sum(chance for name,pop,size,chance in town_size_chances[:n])*100,2),'%')

def get_bottomN_chance(n):
    print('v',n,':', round(sum(chance for name,pop,size,chance in town_size_chances[-n:])*100,2),'%')

get_topN_chance(6)
get_topN_chance(10)
get_topN_chance(20)
get_topN_chance(50)
get_topN_chance(100)
get_topN_chance(650)
print('...')
get_bottomN_chance(650)
get_bottomN_chance(100)
get_bottomN_chance(50)
get_bottomN_chance(20)
get_bottomN_chance(10)
get_bottomN_chance(6)

res = ""
for (town_name,pop,size) in town_size:

    res += f'''        text("{town_name}", {size}),\n'''

#res